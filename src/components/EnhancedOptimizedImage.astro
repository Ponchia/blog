---
import { getImage } from 'astro:assets';
import type { ImageMetadata } from 'astro';

interface Props {
  src: ImageMetadata | string;
  alt: string;
  width?: number; 
  height?: number;
  class?: string;
  loading?: 'lazy' | 'eager';
  decoding?: 'async' | 'sync' | 'auto';
  format?: 'webp' | 'avif' | 'png' | 'jpeg';
  quality?: number; // Allow quality override
  fetchPriority?: 'high' | 'low' | 'auto'; // Control fetch priority
  sizes?: string; // Support responsive images
  placeholder?: 'blur' | 'none'; // Add blur-up placeholder
}

const { 
  src, 
  alt, 
  width, 
  height, 
  class: className = '',
  loading = 'lazy',
  decoding = 'async',
  format = 'webp',
  quality = 80, // Default quality from astro.config.mjs
  fetchPriority = 'auto',
  sizes,
  placeholder = 'none'
} = Astro.props;

// Process the image using sharp
let optimizedImage = { src: typeof src === 'object' && 'src' in src ? src.src : src };
let placeholderImage = null;

try {
  // For ImageMetadata objects (import from assets)
  if (typeof src === 'object' && 'src' in src) {
    optimizedImage = await getImage({
      src: src,
      width: width,
      height: height,
      format: format,
      quality: quality
    });
    
    // Generate low-quality placeholder if requested
    if (placeholder === 'blur') {
      placeholderImage = await getImage({
        src: src,
        width: width ? Math.min(width, 20) : 20, // Very small for blur effect
        height: height ? Math.min(height, 20) : undefined,
        format: format,
        quality: 20 // Low quality for placeholder
      });
    }
  } 
  // For string URLs (public directory or external)
  else if (typeof src === 'string') {
    if (src.startsWith('http')) {
      // External URL - can't optimize these with getImage directly
      // In a production environment, you might want to implement a remote image fetching
      // and caching strategy here
      optimizedImage = { src };
    } else {
      // For local public directory images, we can still use the path
      // but we should encourage using imported assets instead
      optimizedImage = { src };
      console.warn(`Consider importing the image from assets directory for better optimization: ${src}`);
    }
  }
} catch (error) {
  console.error(`Failed to optimize image: ${error}`);
  // Fallback to original
  optimizedImage = { src: typeof src === 'object' && 'src' in src ? src.src : src };
}

// Determine if we should show a placeholder
const showPlaceholder = placeholder === 'blur' && placeholderImage;
---

{showPlaceholder && (
  <div class="optimized-image-container">
    <img 
      src={placeholderImage.src} 
      alt={alt}
      width={width} 
      height={height}
      class={`${className} placeholder-image`}
      aria-hidden="true"
      style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; filter: blur(10px); transform: scale(1.1); opacity: 1; transition: opacity 0.5s ease-in-out;"
    />
    <img 
      src={optimizedImage.src} 
      alt={alt}
      width={width} 
      height={height}
      class={className}
      loading={loading}
      decoding={decoding}
      fetchpriority={fetchPriority}
      sizes={sizes}
      onload="this.previousElementSibling.style.opacity = 0;"
    />
  </div>
)}

{!showPlaceholder && (
  <img 
    src={optimizedImage.src} 
    alt={alt}
    width={width} 
    height={height}
    class={className}
    loading={loading}
    decoding={decoding}
    fetchpriority={fetchPriority}
    sizes={sizes}
  />
)}

<style>
  .optimized-image-container {
    position: relative;
    overflow: hidden;
    display: inline-block;
  }
  
  .placeholder-image {
    pointer-events: none;
  }
</style>